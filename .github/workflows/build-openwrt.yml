name: Build OpenWrt (Full Auto - Optimized, Patches, Upstream, Debug, Artifacts)

on:
  push:
    branches: ["main"]
  schedule:
    - cron: "0 2 * * *"  # daily snapshot at 02:00 UTC
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  checks: write

env:
  OPENWRT_DIR: src
  CCACHE_DIR: ${{ runner.temp }}/ccache
  CCACHE_MAXSIZE: 5G
  MAX_BUILD_RETRIES: 2
  SNAPSHOT_HOUR: "02:00 UTC"
  ARTIFACT_RETENTION_DAYS: 30

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 540

    steps:
      # ---------------------------------------------------------
      # Checkout repository (full history to be able to diff)
      # ---------------------------------------------------------
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------
      # Determine build type (snapshot if schedule)
      # Outputs:
      #   snapshot=true|false
      # ---------------------------------------------------------
      - name: Determine build type
        id: buildtype
        run: |
          echo "event=${GITHUB_EVENT_NAME}" >> $GITHUB_OUTPUT
          if [ "${GITHUB_EVENT_NAME}" = "schedule" ]; then
            echo "snapshot=true" >> $GITHUB_OUTPUT
          else
            echo "snapshot=false" >> $GITHUB_OUTPUT
          fi

      # ---------------------------------------------------------
      # Install dependencies (minimal + jq + dos2unix)
      # ---------------------------------------------------------
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential gcc-multilib g++-multilib \
            flex bison gawk libncurses-dev libssl-dev \
            python3-distutils python3-setuptools zlib1g-dev \
            rsync swig unzip wget ccache jq dos2unix patch \
            git-core rsync

      # ---------------------------------------------------------
      # Clone OpenWrt source
      # ---------------------------------------------------------
      - name: Clone OpenWrt source
        run: |
          rm -rf $OPENWRT_DIR
          git clone --depth 1 https://github.com/openwrt/openwrt.git $OPENWRT_DIR

      # ---------------------------------------------------------
      # Copy custom .config into the OpenWrt tree
      # expects repo/config/.config present
      # ---------------------------------------------------------
      - name: Copy custom .config
        run: |
          if [ ! -f config/.config ]; then
            echo "ERROR: config/.config not found in repository root" >&2
            exit 1
          fi
          cp config/.config $OPENWRT_DIR/.config
          ls -l $OPENWRT_DIR/.config

      # ---------------------------------------------------------
      # Basic .config validation
      # ---------------------------------------------------------
      - name: Validate .config (basic checks)
        id: cfgvalidate
        run: |
          cd $OPENWRT_DIR
          if ! grep -q '^CONFIG_TARGET_BOARD' .config; then
            echo "::error ::Missing CONFIG_TARGET_BOARD in .config"
            exit 1
          fi
          if ! grep -q '^CONFIG_TARGET_PROFILE' .config; then
            echo "::warning ::No CONFIG_TARGET_PROFILE set — build may produce multiple profiles"
          fi

      # ---------------------------------------------------------
      # Discover patches changed since last commit (best-effort)
      # Produces: outputs.files and outputs.discovered
      # ---------------------------------------------------------
      - name: Discover new patches (since last commit)
        id: patches_new
        run: |
          # attempt to find changed patch files since previous commit (best-effort)
          git fetch --no-tags --prune --depth=50 origin main || true
          LAST_COMMIT=$(git rev-parse HEAD~1 2>/dev/null || true)
          if [ -n "$LAST_COMMIT" ]; then
            git diff --name-only $LAST_COMMIT..HEAD -- patches || true
          else
            ls patches || true
          fi > /tmp/patch_file_list || true
          FILES=$(cat /tmp/patch_file_list | tr '\n' ' ')
          COUNT=$(cat /tmp/patch_file_list | wc -l || true)
          echo "files=$FILES" >> $GITHUB_OUTPUT
          echo "discovered=$COUNT" >> $GITHUB_OUTPUT
          echo "Patches discovered: $FILES"
          cat /tmp/patch_file_list || true

      # ---------------------------------------------------------
      # Auto-format patches: dos2unix, normalize whitespace,
      # and run git apply --check as a linter (no push performed)
      # ---------------------------------------------------------
      - name: Auto-format patches (dos2unix + lint)
        run: |
          shopt -s nullglob
          printf "Formatting patches...\n"
          for f in patches/*.patch; do
            [ -f "$f" ] || continue
            printf " - %s\n" "$f"
            dos2unix "$f" || true
            sed -i -e 's/[[:space:]]*$//' "$f" || true
            if ! git apply --check "$f" 2>/tmp/patch_check_err; then
              printf "::warning ::Patch %s failed git apply --check; recorded to patch_check_errors.txt\n" "$f"
              echo "Patch $f failed git apply --check" >> patch_check_errors.txt
              cat /tmp/patch_check_err >> patch_check_errors.txt || true
            fi
          done
          if [ -f patch_check_errors.txt ]; then
            echo "Some patches raised warnings during lint. See patch_check_errors.txt"
            ls -l patch_check_errors.txt || true
          fi

      # ---------------------------------------------------------
      # Apply patches (dry-run then apply) into the OpenWrt tree.
      # Patches are applied in numeric sort order (000..999).
      # This step does not commit or push; it modifies build tree only.
      # ---------------------------------------------------------
      - name: Apply patches (dry-run then apply)
        id: patches_apply
        run: |
          set -e
          cd $OPENWRT_DIR
          mkdir -p package/kernel/mt76/patches
          mkdir -p dts_patches
          echo "Applying patches into build tree..."
          applied_list="/tmp/applied_patches.txt"
          failed_list="/tmp/failed_patches.txt"
          rm -f $applied_list $failed_list || true
          for p in ../patches/*.patch; do
            [ -f "$p" ] || continue
            echo "DRY-RUN $p"
            if patch --dry-run -p1 < "$p" 2>/tmp/patcherr; then
              echo "Applying $p"
              patch -p1 < "$p"
              echo "$p" >> $applied_list
            else
              echo "Patch $p failed dry-run; saving error"
              echo "$p failed" >> $failed_list
              cat /tmp/patcherr >> ../patch-apply-errors.log || true
            fi
          done
          if [ -f $applied_list ]; then
            echo "Applied patches:"
            cat $applied_list
            cp $applied_list ..
          else
            echo "No patches applied."
          fi
          if [ -f $failed_list ]; then
            echo "Failed patches:"
            cat $failed_list
            cp $failed_list ..
          fi

      # ---------------------------------------------------------
      # Show patch summary artifacts (so they will be uploaded)
      # ---------------------------------------------------------
      - name: Show patch summary (workspace copies)
        if: always()
        run: |
          echo "Patch summary files in repo root (if present):"
          ls -la ../applied_patches.txt ../failed_patches.txt ../patch-apply-errors.log || true
          for f in ../applied_patches.txt ../failed_patches.txt ../patch-apply-errors.log; do
            [ -f "$f" ] && echo "---- $f ----" && sed -n '1,200p' "$f" || true
          done

      # ---------------------------------------------------------
      # Apply any DTS patches from repo/dts_patches (if present)
      # ---------------------------------------------------------
      - name: Apply dts_patches (optional)
        run: |
          cd $OPENWRT_DIR
          if [ -d ../dts_patches ]; then
            for f in ../dts_patches/*.patch; do
              [ -f "$f" ] || continue
              echo "Applying DTS patch $f"
              patch -p1 < "$f" || echo "DTS patch $f failed"
            done
          else
            echo "No dts_patches/ folder found; skipping"
          fi

      # ---------------------------------------------------------
      # Update feeds and install
      # ---------------------------------------------------------
      - name: Update feeds and install
        run: |
          cd $OPENWRT_DIR
          ./scripts/feeds update -a
          ./scripts/feeds install -a

      # ---------------------------------------------------------
      # Expand .config (make defconfig)
      # ---------------------------------------------------------
      - name: Expand .config (make defconfig)
        run: |
          cd $OPENWRT_DIR
          make defconfig

      # ---------------------------------------------------------
      # Generate changelog between last tag/commit and current HEAD.
      # Outputs: steps.changelog.outputs.log
      # ---------------------------------------------------------
      - name: Generate changelog
        id: changelog
        run: |
          # Try to find a previous tag; if none, use HEAD~1 as fallback
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          if [ -n "$PREV_TAG" ]; then
            RANGE="$PREV_TAG..HEAD"
          else
            PREV_COMMIT=$(git rev-parse HEAD~1 2>/dev/null || true)
            if [ -n "$PREV_COMMIT" ]; then
              RANGE="$PREV_COMMIT..HEAD"
            else
              RANGE=""
            fi
          fi
          if [ -z "$RANGE" ]; then
            echo "log=First build — no changelog available." >> $GITHUB_OUTPUT
            echo "First build — no changelog available." > changelog.txt
          else
            git log --pretty=format:"• %h - %s (%an)" $RANGE > changelog.txt || true
            LOG_CONTENT=$(cat changelog.txt || echo "No log")
            printf "log<<EOF\n%s\nEOF\n" "$LOG_CONTENT" >> $GITHUB_OUTPUT
          fi
          echo "Changelog generated:"
          sed -n '1,200p' changelog.txt || true

      # ---------------------------------------------------------
      # Detect target / subtarget / profile / wifi packages
      # Outputs: steps.detect.outputs.{target,subtarget,profile,wifi}
      # ---------------------------------------------------------
      - name: Detect target, subtarget, profile, wifi
        id: detect
        run: |
          cd $OPENWRT_DIR
          TARGET=$(grep '^CONFIG_TARGET_BOARD' .config 2>/dev/null | sed 's/.*=//' | tr -d '"' || true)
          SUBTARGET=$(grep '^CONFIG_TARGET_SUBTARGET' .config 2>/dev/null | sed 's/.*=//' | tr -d '"' || true)
          PROFILE_RAW=$(grep '^CONFIG_TARGET_PROFILE' .config 2>/dev/null | sed 's/.*=//' | tr -d '"' || true)
          # best-effort profile cleanup
          PROFILE=$(echo "$PROFILE_RAW" | sed -e 's/^DEVICE_//' -e 's/^.*_//' || true)
          WIFI=$(grep -E "CONFIG_PACKAGE_(iw|iwinfo|hostapd|wpad|mt76|ath10k|ath9k)" .config 2>/dev/null || true)
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "subtarget=$SUBTARGET" >> $GITHUB_OUTPUT
          echo "profile=$PROFILE" >> $GITHUB_OUTPUT
          # compress wifi list on one line
          WIFI_ONE_LINE=$(echo "$WIFI" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ //;s/ $//')
          echo "wifi=$WIFI_ONE_LINE" >> $GITHUB_OUTPUT
          echo "Detected: $TARGET / $SUBTARGET profile=$PROFILE wifi=$WIFI_ONE_LINE"

      # ---------------------------------------------------------
      # Print some pre-build stats
      # ---------------------------------------------------------
      - name: Print pre-build stats
        run: |
          echo "Config lines:"
          wc -l $OPENWRT_DIR/.config || true
          echo "Top directories:"
          ls -la $OPENWRT_DIR/package | head -n 20 || true

      # ---------------------------------------------------------
      # Configure build optimization (LTO toggle via secret,
      # global cflags via secret). Safe modifications only.
      # ---------------------------------------------------------
      - name: Configure build optimization (safe)
        run: |
          cd $OPENWRT_DIR
          # Enable CCACHE if desired
          if [ "${ENABLE_LTO:-}" = "true" ] || [ "${{ secrets.ENABLE_LTO }}" = "true" ]; then
            echo "CONFIG_LTO=y" >> .config || true
          fi
          if [ -n "${{ secrets.GLOBAL_CFLAGS }}" ]; then
            # Do not force arbitrary flags that break builds; provide a safe hint
            echo "::warning ::GLOBAL_CFLAGS is set in secrets; custom flags injection is advanced and may break builds."
          fi

      # ---------------------------------------------------------
      # Prepare ccache environment
      # ---------------------------------------------------------
      - name: Configure ccache
        run: |
          mkdir -p "${CCACHE_DIR}"
          echo "CCACHE_DIR=${CCACHE_DIR}"
          ccache --version || true
          ccache -s || true

      # ---------------------------------------------------------
      # Build with retry logic. Build logs to ../build_full.log
      # On failure the job continues to the debug steps which upload logs.
      # ---------------------------------------------------------
      - name: Build firmware (with retries)
        id: buildstep
        run: |
          cd $OPENWRT_DIR
          export CCACHE_DIR="${CCACHE_DIR}"
          export CCACHE_MAXSIZE="${CCACHE_MAXSIZE}"
          mkdir -p "${CCACHE_DIR}"
          attempts=0
          max=${MAX_BUILD_RETRIES}
          set -o pipefail
          while [ $attempts -le $max ]; do
            attempts=$((attempts+1))
            echo "=== Build attempt $attempts ==="
            START=$(date +%s)
            if make -j$(nproc) V=s 2>&1 | tee ../build_full.log; then
              END=$(date +%s)
              echo "BUILD_OK" > ../build_status || true
              echo "duration=$((END-START))" >> ../build_status || true
              echo "Build succeeded on attempt $attempts"
              exit 0
            else
              echo "Build attempt $attempts failed"
              if [ $attempts -gt $max ]; then
                echo "All build attempts failed" > ../build_status
                exit 1
              fi
              echo "Retrying in 5s..."
              sleep 5
            fi
          done

      # ---------------------------------------------------------
      # Collect debug info (always) — small curated set to avoid huge uploads
      # ---------------------------------------------------------
      - name: Collect debug info (always)
        if: always()
        run: |
          TS=$(date -u +"%Y%m%dT%H%M%SZ")
          LOGDIR=".github/workflow-logs/${TS}"
          mkdir -p "${LOGDIR}"
          # copy main build_full.log if present
          if [ -f ../build_full.log ]; then
            cp ../build_full.log "${LOGDIR}/build_full.log" || true
          fi
          # collect package build logs (first-level)
          rsync -a --ignore-missing-args $OPENWRT_DIR/build_dir/host "${LOGDIR}/" || true
          rsync -a --ignore-missing-args $OPENWRT_DIR/build_dir/package "${LOGDIR}/" || true
          # small staging_dir snapshot (exclude large packages)
          tar -czf "${LOGDIR}/staging_dir_small.tgz" --exclude='staging_dir/**/pkg' --exclude='staging_dir/toolchain-*/pkg' staging_dir 2>/dev/null || true
          uname -a > "${LOGDIR}/sysinfo.txt" || true
          echo "ccache stats:" > "${LOGDIR}/ccache.txt" || true
          ccache -s >> "${LOGDIR}/ccache.txt" || true
          echo "Collected debug files in ${LOGDIR}"

      # ---------------------------------------------------------
      # Upload debug logs artifact (always)
      # ---------------------------------------------------------
      - name: Upload debug logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-debug-${{ github.run_id }}
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          path: |
            .github/workflow-logs/
            ../build_full.log
            $OPENWRT_DIR/logs/
            $OPENWRT_DIR/build_dir/
            $OPENWRT_DIR/staging_dir/

      # ---------------------------------------------------------
      # Package artifacts and metadata only if build succeeded
      # ---------------------------------------------------------
      - name: Package artifacts and metadata
        if: success()
        run: |
          cd $OPENWRT_DIR
          OUTDIR=../artifacts/${GITHUB_RUN_ID}
          mkdir -p "$OUTDIR"
          TARGET="${{ steps.detect.outputs.target || '' }}"
          SUB="${{ steps.detect.outputs.subtarget || '' }}"
          if [ -z "$TARGET" ] || [ -z "$SUB" ]; then
            # try to detect from bin tree if not available
            if [ -d bin/targets ]; then
              TARGET=$(ls bin/targets | head -n1 || true)
              SUB=$(ls bin/targets/$TARGET | head -n1 || true)
            fi
          fi
          mkdir -p "$OUTDIR/$TARGET/$SUB"
          cp -a bin/targets/$TARGET/$SUB/* "$OUTDIR/$TARGET/$SUB/" || true
          pushd "$OUTDIR/$TARGET/$SUB" >/dev/null 2>&1 || true
          # generate sha256sums
          if ls 2>/dev/null | grep -q .; then
            sha256sum * > sha256sums.txt || true
          fi
          # split sysupgrade vs factory by filename (best-effort)
          for img in *.bin; do
            [ -f "$img" ] || continue
            if echo "$img" | grep -q "sysupgrade"; then
              mkdir -p sysupgrade
              mv "$img" sysupgrade/ || true
            else
              mkdir -p factory
              mv "$img" factory/ || true
            fi
          done
          popd >/dev/null 2>&1 || true
          echo "Artifacts prepared in $OUTDIR"

      # ---------------------------------------------------------
      # Upload built firmware artifacts (only on success)
      # ---------------------------------------------------------
      - name: Upload firmware artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ github.run_id }}
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          path: artifacts/${{ github.run_id }}/
          if-no-files-found: error

      # ---------------------------------------------------------
      # Maintain latest pointer locally (no push) - write to artifact
      # ---------------------------------------------------------
      - name: Create latest snapshot metadata (artifact)
        if: success()
        run: |
          METADIR="../artifacts/${GITHUB_RUN_ID}/meta"
          mkdir -p "$METADIR"
          echo "run_id=${GITHUB_RUN_ID}" > "$METADIR/snapshot-latest.txt"
          date -u +"date=%Y-%m-%dT%H:%M:%SZ" >> "$METADIR/snapshot-latest.txt"
          echo "profile=${{ steps.detect.outputs.profile || 'unknown' }}" >> "$METADIR/snapshot-latest.txt"
          echo "target=${{ steps.detect.outputs.target || 'unknown' }}" >> "$METADIR/snapshot-latest.txt"
          echo "Created metadata in $METADIR"

      # ---------------------------------------------------------
      # Create GitHub Release for snapshot builds (attach artifacts)
      # Note: softprops/action-gh-release attaches files from the runner filesystem.
      # ---------------------------------------------------------
      - name: Create GitHub Release (snapshot)
        if: steps.buildtype.outputs.snapshot == 'true' && success()
        uses: softprops/action-gh-release@v2
        with:
          tag_name: snapshot-${{ steps.detect.outputs.profile || 'unknown' }}-${{ github.run_id }}
          name: "Snapshot - ${{ steps.detect.outputs.profile || 'unknown' }} - ${{ github.run_id }}"
          body: |
            Device: ${{ steps.detect.outputs.profile || 'unknown' }}
            Target: ${{ steps.detect.outputs.target || 'unknown' }}/${{ steps.detect.outputs.subtarget || 'unknown' }}
            Date (UTC): ${{ now('utc') }}
            WiFi packages: ${{ steps.detect.outputs.wifi || 'none' }}

            Changelog:
            ${{ steps.changelog.outputs.log || 'No changelog available.' }}
          # attach everything under artifacts/<run_id>
          files: |
            artifacts/${{ github.run_id }}/**

      # ---------------------------------------------------------
      # Prune old artifacts note (no deletion)
      # ---------------------------------------------------------
      - name: Prune old artifacts (note)
        if: success()
        run: |
          echo "Pruning not implemented in this workflow (no push perms). Use a separate cleanup workflow if desired."

      # ---------------------------------------------------------
      # Final status output
      # ---------------------------------------------------------
      - name: Summary
        run: |
          echo "Workflow completed for run: ${GITHUB_RUN_ID}"
          echo "Build snapshot: ${{ steps.buildtype.outputs.snapshot }}"
          echo "Target: ${{ steps.detect.outputs.target || 'unknown' }}"
          echo "Subtarget: ${{ steps.detect.outputs.subtarget || 'unknown' }}"
          echo "Profile: ${{ steps.detect.outputs.profile || 'unknown' }}"
          echo "Artifacts: artifacts/${GITHUB_RUN_ID}/"
